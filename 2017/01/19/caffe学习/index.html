<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>caffe学习总结 › Don&#39;t Respond</title>
  <meta name="author" content="Dou Jiang">
  
  <meta name="description" content="#caffe学习总结
##caffe的由来 caffe是贾扬清在UC
Berkeley攻读计算机科学博士学位时开发的一套深度学习框架，由于高效、易读和模块化的设计，开源后经过nvidia的帮助优化和社区不断的完善，如今成为视觉领域主流的框架之一。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="caffe学习总结"/>
  <meta property="og:site_name" content="Don&#39;t Respond"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Don&#39;t Respond" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  <header id="header"><div class="meta inner">
  <h1><a href="/">Don&#39;t Respond</a></h1>
  <h2><a href="/"></a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title">caffe学习总结</h1>
  

      
        <time datetime="2017-01-19T04:31:08.000Z">2017-01-19</time>
      
    </header>
    <div class="entry">
      
        <p>#caffe学习总结</p>
<p>##caffe的由来 caffe是贾扬清在UC
Berkeley攻读计算机科学博士学位时开发的一套深度学习框架，由于高效、易读和模块化的设计，开源后经过nvidia的帮助优化和社区不断的完善，如今成为视觉领域主流的框架之一。</p>
<span id="more"></span>
<ul>
<li><p>贾扬清其人<br />
清华大学的本硕，UC Berkeley的计算机科学博士，师承Prof. Trevor
Darrell，期间在新加坡国立大学、微软亚洲研究院、NEC美国实验室和google研究院实习和工作。博士毕业后一直在google
brain担任研究科学家，致力于机器视觉、深度学习和tensorflow相关工作。2016年2月加入facebook，主导facebook大多数AI应用的通用、大规模机器学习平台（目前以caffe2为基础的caffe2go已经开源）。</p></li>
<li><p>为什么要开发caffe<br />
贾最早开发的是另一款软件Decaf，主要功能是基于cuda-convnet进行CNN训练。2013年贾扬清读博期间跟心理学老师合作研究使用概率框架来表达人的行为，"但是因为图像上提取的特征比较弱，所以可以外推的结果比较有限"，而2012年Alex
Krizhevsky提出的AlexNet在ImageNet比赛中大获成功，贾因此也希望将CNN应用到他们的心理学研究上，于是就开始写了Decaf，通过Decaf验证了"深度学习特征的优异的可移植性"，因此就开始开发一套通用的深度学习框架，即后来的caffe。</p></li>
</ul>
<p>##caffe与其他一些主流框架的比较
caffe同期也存在其他一些开源框架，比如cuda-convnet、theano、torch等，并且后来又陆续开源了neon、mxnet、tensorflow、CNTK以及paddled等等。现在对于研究者，如何选择一个框架也成了一个麻烦的问题了。下图是2014年贾扬清在caffe论文中对当时的一些框架做的一个比较：</p>
<div data-align="center">
<img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-001.png?raw=true width=800>
</div>
<p>下面是近年主流框架的一个简单比较：</p>
<ul>
<li>特性</li>
</ul>
<table style="width:100%;">
<colgroup>
<col style="width: 18%" />
<col style="width: 21%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">主语言</th>
<th style="text-align: center;">从语言</th>
<th style="text-align: center;">硬件</th>
<th style="text-align: center;">分布式</th>
<th style="text-align: center;">命令式</th>
<th style="text-align: center;">声明式</th>
<th style="text-align: center;">自动梯度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>caffe</td>
<td style="text-align: center;">C++</td>
<td style="text-align: center;">Python/Matlab</td>
<td style="text-align: center;">CPU/GPU</td>
<td style="text-align: center;">✖</td>
<td style="text-align: center;">✖</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✖</td>
</tr>
<tr class="even">
<td>mxnet</td>
<td style="text-align: center;">C++</td>
<td style="text-align: center;">Python/R/Julia/Scala</td>
<td style="text-align: center;">CPU/GPU/Mobile</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
</tr>
<tr class="odd">
<td>tensorflow</td>
<td style="text-align: center;">C++</td>
<td style="text-align: center;">Python</td>
<td style="text-align: center;">CPU/GPU/Mobile</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✖</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
</tr>
<tr class="even">
<td>Torch</td>
<td style="text-align: center;">Lua</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">CPU/GPU/FPGA</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✖</td>
<td style="text-align: center;">✔</td>
</tr>
<tr class="odd">
<td>theano</td>
<td style="text-align: center;">Python</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">CPU/GPU</td>
<td style="text-align: center;">✖</td>
<td style="text-align: center;">✖</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
</tr>
</tbody>
</table>
<ul>
<li>效率
<div data-align="center">
<img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-002.png?raw=true width=420>
</div></li>
</ul>
<p>##caffe代码组织结构
caffe代码结构是非常清晰的，主要包含以下文件和目录：</p>
<ul>
<li>Makefile和Makefile.config
caffe支持cmake和make两种编译方式，不过大部分人只需要用make编译就可以了。Makefile.config可以对一些编译选项进行配置，比如USE_MPI、CPU_ONLY、DEBUG等等。</li>
<li>include
在caffe中除了proto文件生成的头文件外，所有的c++头文件都放在include目录中。</li>
<li>src
src与include的目录结构基本上相同，include目录中的文件基本上都能在src目录中找到对应的实现文件。</li>
<li>tools
tools目录下是caffe提供给用户直接使用的接口，比如caffe.cpp用于模型训练、评估以及统计耗时，另外也提供一些数据集转换、计算均值等工具</li>
<li>examples
提供一些训练相关的脚本和网络配置，比如数据预处理脚本、不同的网络配置文件以及训练脚本</li>
<li>models
提供一些模型的网络配置文件，以及训练好的模型，用户可以直接用训练好的模型进行fine-tune或者分类</li>
<li>matlab/python 提供matlab和python的接口</li>
</ul>
<p>##caffe网络的组织方式
从LeNet开始，CNN就开始有了一个标准的分层结构——堆叠卷积层，卷积层可能后接一些normalization和pooling层，网络最后接一个或多个全连接层。由于梯度下降算法非常适合逐层计算，因此当时很多的通用框架都将网络（Net）抽象为多个数据处理层（Layer）组成的有向图，并支持灵活地定义网络结构。caffe将神经网络的训练问题分解为四个方面：数据、计算、流动控制以及问题求解，分别对应caffe中的Blob、Layer、Net和Solver。网络中流动的数据以及参数都用Blob来表示，Layer负责前向输出和后向梯度的计算，Net负责控制Layer计算的顺序，Solver是一个求解器的角色，根据Net的梯度对网络参数进行更新。</p>
<p><img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-003.png?raw=true width=800></p>
<p>[待补充]</p>
<p>##caffe中的Blob及同步策略
Blob是caffe中存储数据的基本结构，可以简单理解为一个4维的数组，数据组织格式为（N,C,H,W）。在caffe中上下层流动的数据和每层的权重参数都是用Blob来保存的，为了便于使用，Blob具有一些特性：</p>
<ul>
<li>Blob的内存是懒分配的（lazily
allocate），只有在真正使用的时候才会分配内存</li>
<li>Blob会在CPU和GPU上各自分配一块相同大小的内存，便于在CPU和GPU之间进行切换</li>
<li>用户不需要关心CPU和GPU数据的同步，Blob会根据需要自动同步</li>
</ul>
<p>下面是Blob的成员变量，data_是Blob存储的数据，diff_保存的是数据的梯度，shape_data_和shape_保存的都是当前数组的形状，count_是当前数据的大小，capacity_是申请的内存的大小，避免每次Reshape都要释放并重新申请内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/caffe/blob.hpp</span></span><br><span class="line">shared_ptr&lt;SyncedMemory&gt; data_;</span><br><span class="line">shared_ptr&lt;SyncedMemory&gt; diff_;</span><br><span class="line">shared_ptr&lt;SyncedMemory&gt; shape_data_;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; shape_;</span><br><span class="line"><span class="type">int</span> count_;</span><br><span class="line"><span class="type">int</span> capacity_;</span><br></pre></td></tr></table></figure>
<p>下面主要说一下Blob的自动同步策略。首先看一下SyncedMemory的成员变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/caffe/syncedmem.hpp</span></span><br><span class="line"><span class="type">void</span>* cpu_ptr_; <span class="comment">// CPU内存数据</span></span><br><span class="line"><span class="type">void</span>* gpu_ptr_; <span class="comment">// GPU显存数据</span></span><br><span class="line"><span class="type">size_t</span> size_;   <span class="comment">// 数据大小</span></span><br><span class="line">SyncedHead head_;  <span class="comment">// 同步标志</span></span><br><span class="line"><span class="type">bool</span> own_cpu_data_; </span><br><span class="line"><span class="type">bool</span> cpu_malloc_use_cuda_;</span><br><span class="line"><span class="type">bool</span> own_gpu_data_;</span><br><span class="line"><span class="type">int</span> gpu_device_; <span class="comment">// GPU设备号</span></span><br></pre></td></tr></table></figure>
<p>head_的取值范围为UNINITIALIZED, HEAD_AT_CPU, HEAD_AT_GPU,
SYNCED。初始化时head_值为UNINITIALIZED，当调用Blob的取值函数时都会调用一次SyncedMemory的to_cpu或者to_gpu进行数据的同步，同步策略为：<br />
1、取cpu数据时，会调用to_cpu函数，如果heda_为HEAD_AT_GPU，则需要将GPU的数据同步至CPU，否则不需要同步<br />
2、取gpu数据时，会调用to_gpu函数，如果heda_为HEAD_AT_CPU，则需要将CPU的数据同步至GPU，否则不需要同步</p>
<p>head_标志的赋值：<br />
1、每次调用SyncedMemory的mutable_cpu_data时，head_都会被置为HEAD_AT_CPU<br />
2、每次调用SyncedMemory的mutable_gpu_data时，head_都会被置为HEAD_AT_GPU<br />
3、每次同步之后heda_会被置为SYNCED。</p>
<p>因此Blob通过判断每次修改的位置来自行决定是否需要对不同设备间的两份数据进行同步，使用时就像只有一份数据一样，非常方便。</p>
<p>##caffe中的Layer
layer是caffe模型的主要组成部分和基本的计算单元，与很多框架中的operator对应，一个典型的layer在forward时从下层连接获取输入，经过计算后输出到上层，backward时又从上层连接获取误差，计算本层梯度和误差后，将误差传递到下层连接。因此基类Layer实现了三个基本函数setup、forward和backward。</p>
<ul>
<li>setup：根据下层连接和配置参数完成本层参数的初始化，以及输出blobs的初始化</li>
<li>forward：前向计算过程，并计算本层的loss</li>
<li>backward：后向计算过程，并将本层误差传递到下层</li>
</ul>
<p>forward和backward里面都会对CPU和GPU进行分支，如果是CPU模式，则真正参与计算的是forward_cpu和backward_cpu，如果是GPU模式，则参与计算的是forward_gpu和backward_gpu，并且在基类中forward_gpu和backward_gpu分别调用的是forward_cpu和backward_cpu，当然用户在定义新的layer时可以自行实现forward_gpu和backward_gpu。</p>
<p>基类Layer的成员变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/caffe/layer.hpp</span></span><br><span class="line"><span class="comment">/** The protobuf that stores the layer parameters */</span></span><br><span class="line">LayerParameter layer_param_;</span><br><span class="line"><span class="comment">/** The phase: TRAIN or TEST */</span></span><br><span class="line">Phase phase_;</span><br><span class="line"><span class="comment">/** The vector that stores the learnable parameters as a set of blobs. */</span></span><br><span class="line">vector&lt;shared_ptr&lt;Blob&lt;Dtype&gt; &gt; &gt; blobs_;</span><br><span class="line"><span class="comment">/** Vector indicating whether to compute the diff of each param blob. */</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; param_propagate_down_;</span><br><span class="line"><span class="comment">/** The vector that indicates whether each top blob has a non-zero weight in</span></span><br><span class="line"><span class="comment"> *  the objective function. */</span></span><br><span class="line">vector&lt;Dtype&gt; loss_;</span><br></pre></td></tr></table></figure>
<p>layer_param_是从protobuf文件中反序列化得到的，存放的是layer的配置参数
phase_指示是训练还是测试 blobs_是本层的参数，比如权重和偏置
param_propagate_down_为每一个参数设定是否需要计算梯度
loss_是本层的损失值，loss层每个输出blob都有一个损失值，非loss层损失为0</p>
<p>由基类Layer直接或间接派生出各种layer，比如卷积(convolution)、全连接(fully
connected或者inner
product)、dropout、pooling、relu、softmaxWithLoss等等，每一个派生layer都会强制实现forward_cpu和backward_cpu。早期的caffe将layer分成5类，</p>
<ul>
<li>dataLayer类： 各类数据读取的接口</li>
<li>neuronLayer类： 各种激活函数、dropout</li>
<li>visionLayer类： 卷积层、采样层等2D图像相关的运算</li>
<li>commonLayer类：全连接层和其他运算</li>
<li>lossLayer类：实现各种代价函数</li>
</ul>
<p>不过目前最新版本的caffe已经取消了visionLayer和commonLayer的分类。此外由于caffe使用了cuDNN运算加速库，因此部分layer有caffe和cuDNN两种实现，使用时可以通过protobuf文件配置需要使用的engine。</p>
<p>为了保持框架的可扩展性，大多数框架在layer或者operator的实现中使用了工厂模式，使用统一的工厂类来对不同的layer或operator进行实例化。下面是caffe使用工厂模式的代码实现，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/caffe/layer_factory.hpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LayerRegistry</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> shared_ptr&lt;Layer&lt;Dtype&gt; &gt; (*Creator)(<span class="type">const</span> LayerParameter&amp;);</span><br><span class="line">  <span class="keyword">typedef</span> std::map&lt;string, Creator&gt; CreatorRegistry;</span><br><span class="line">  <span class="function"><span class="type">static</span> CreatorRegistry&amp; <span class="title">Registry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> CreatorRegistry* g_registry_ = <span class="keyword">new</span> <span class="built_in">CreatorRegistry</span>();</span><br><span class="line">    <span class="keyword">return</span> *g_registry_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Adds a creator.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">AddCreator</span><span class="params">(<span class="type">const</span> string&amp; type, Creator creator)</span> </span>&#123;</span><br><span class="line">    CreatorRegistry&amp; registry = <span class="built_in">Registry</span>();</span><br><span class="line">    <span class="built_in">CHECK_EQ</span>(registry.<span class="built_in">count</span>(type), <span class="number">0</span>)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Layer type &quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot; already registered.&quot;</span>;</span><br><span class="line">    registry[type] = creator;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LayerRegisterer</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LayerRegisterer</span>(<span class="type">const</span> string&amp; type,</span><br><span class="line">                  shared_ptr&lt;Layer&lt;Dtype&gt; &gt; (*creator)(<span class="type">const</span> LayerParameter&amp;)) &#123;</span><br><span class="line">    <span class="comment">// LOG(INFO) &lt;&lt; &quot;Registering layer type: &quot; &lt;&lt; type;</span></span><br><span class="line">    LayerRegistry&lt;Dtype&gt;::<span class="built_in">AddCreator</span>(type, creator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_LAYER_CREATOR(type, creator)                                  \</span></span><br><span class="line"><span class="meta">  static LayerRegisterer<span class="string">&lt;float&gt;</span> g_creator_f_##type(#type, creator<span class="string">&lt;float&gt;</span>);     \</span></span><br><span class="line"><span class="meta">  static LayerRegisterer<span class="string">&lt;double&gt;</span> g_creator_d_##type(#type, creator<span class="string">&lt;double&gt;</span>)    \</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/caffe/layer_factory.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line">shared_ptr&lt;Layer&lt;Dtype&gt; &gt; <span class="built_in">GetSigmoidLayer</span>(<span class="type">const</span> LayerParameter&amp; param) &#123;</span><br><span class="line">  SigmoidParameter_Engine engine = param.<span class="built_in">sigmoid_param</span>().<span class="built_in">engine</span>();</span><br><span class="line">  <span class="keyword">if</span> (engine == SigmoidParameter_Engine_DEFAULT) &#123;</span><br><span class="line">    engine = SigmoidParameter_Engine_CAFFE;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_CUDNN</span></span><br><span class="line">    engine = SigmoidParameter_Engine_CUDNN;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (engine == SigmoidParameter_Engine_CAFFE) &#123;</span><br><span class="line">    <span class="keyword">return</span> shared_ptr&lt;Layer&lt;Dtype&gt; &gt;(<span class="keyword">new</span> <span class="built_in">SigmoidLayer</span>&lt;Dtype&gt;(param));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_CUDNN</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (engine == SigmoidParameter_Engine_CUDNN) &#123;</span><br><span class="line">    <span class="keyword">return</span> shared_ptr&lt;Layer&lt;Dtype&gt; &gt;(<span class="keyword">new</span> <span class="built_in">CuDNNSigmoidLayer</span>&lt;Dtype&gt;(param));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Layer &quot;</span> &lt;&lt; param.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; has unknown engine.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">REGISTER_LAYER_CREATOR</span>(Sigmoid, GetSigmoidLayer);</span><br></pre></td></tr></table></figure>
<p>##caffe中的Net
Net是由Layer组成的有向图，表示整个神经网络的拓扑结构，与很多框架中的graph对应，一般用一个protobuf文件来定义。而且Layer作为有向图中的一个组件，是无法感知自己的上层和下层连接的，需要Net将数据feed给Layer，这样数据在有向图中才能真正流动起来。因此Net至少需要提供构建一个有向图和feed数据流两种功能。</p>
<ul>
<li>构建一个有向图：void Init(const NetParameter&amp; in_param)</li>
<li>feed数据流： const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp;
Forward(Dtype* loss)和void Backward()</li>
</ul>
<p>在构建有向图时，caffe首先会对不符合规则的layer进行过滤，比如对于test
net，则会把只用于train的layer过滤掉。对于有向图中可能存在分支的情况，caffe会自动插入split层，将原输入blob复制多份，分别输入不同的分支，比如：LeNet网络中的数据层的label需要输入到accuracy层和loss层，那么需要在数据层再插入一层，如下图所示。</p>
<div data-align="center">
<img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-004.jpg?raw=true width=600>
</div>
<p>Net会根据网络结构逐层创建layer，并指定输入输出blobs，以及是否需要backward。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/caffe/net.cpp:Init</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> layer_id = <span class="number">0</span>; layer_id &lt; param.<span class="built_in">layer_size</span>(); ++layer_id) &#123;</span><br><span class="line">    ...</span><br><span class="line">    layers_.<span class="built_in">push_back</span>(LayerRegistry&lt;Dtype&gt;::<span class="built_in">CreateLayer</span>(layer_param));</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> bottom_id = <span class="number">0</span>; bottom_id &lt; layer_param.<span class="built_in">bottom_size</span>(); ++bottom_id) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">int</span> blob_id = <span class="built_in">AppendBottom</span>(param, layer_id, bottom_id,</span><br><span class="line">                                       &amp;available_blobs, &amp;blob_name_to_idx);</span><br><span class="line">      <span class="comment">// If a blob needs backward, this layer should provide it.</span></span><br><span class="line">      need_backward |= blob_need_backward_[blob_id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num_top = layer_param.<span class="built_in">top_size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> top_id = <span class="number">0</span>; top_id &lt; num_top; ++top_id) &#123;</span><br><span class="line">      <span class="built_in">AppendTop</span>(param, layer_id, top_id, &amp;available_blobs, &amp;blob_name_to_idx);</span><br><span class="line">      <span class="comment">// Collect Input layer tops as Net inputs.</span></span><br><span class="line">      <span class="keyword">if</span> (layer_param.<span class="built_in">type</span>() == <span class="string">&quot;Input&quot;</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> blob_id = blobs_.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        net_input_blob_indices_.<span class="built_in">push_back</span>(blob_id);</span><br><span class="line">        net_input_blobs_.<span class="built_in">push_back</span>(blobs_[blob_id].<span class="built_in">get</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    layers_[layer_id]-&gt;<span class="built_in">SetUp</span>(bottom_vecs_[layer_id], top_vecs_[layer_id]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在训练时，train net会首先初始化，test
net之后初始化，每次test时会调用ShareTrainedLayersWith共享train
net的参数，这样做可以节省显存并且避免不必要的数据拷贝。</p>
<p>需要注意的是，在protobuf文件中声明网络结构时，必须依照从下到上的顺序一层一层定义网络参数，而且test
net和train
net对应层的name最好一致(虽然不一致可能不会导致程序报错），因为test
net与train
net是根据匹配name进行参数共享的，如果name不一致则会导致无法进行参数共享，增加显存消耗的同时还会导致test结果不正确。</p>
<p>当有向图构建完成后，我们只需要调用Forward和Backward，数据就能流经整个网络，得到每层的输出、loss和每个参数的梯度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/caffe/net.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line">Dtype Net&lt;Dtype&gt;::<span class="built_in">ForwardFromTo</span>(<span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line">  <span class="built_in">CHECK_GE</span>(start, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">CHECK_LT</span>(end, layers_.<span class="built_in">size</span>());</span><br><span class="line">  Dtype loss = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">    <span class="comment">// LOG(ERROR) &lt;&lt; &quot;Forwarding &quot; &lt;&lt; layer_names_[i];</span></span><br><span class="line">    Dtype layer_loss = layers_[i]-&gt;<span class="built_in">Forward</span>(bottom_vecs_[i], top_vecs_[i]);</span><br><span class="line">    loss += layer_loss;</span><br><span class="line">    <span class="keyword">if</span> (debug_info_) &#123; <span class="built_in">ForwardDebugInfo</span>(i); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> loss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="type">void</span> Net&lt;Dtype&gt;::<span class="built_in">BackwardFromTo</span>(<span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line">  <span class="built_in">CHECK_GE</span>(end, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">CHECK_LT</span>(start, layers_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = start; i &gt;= end; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (layer_need_backward_[i]) &#123;</span><br><span class="line">      layers_[i]-&gt;<span class="built_in">Backward</span>(</span><br><span class="line">          top_vecs_[i], bottom_need_backward_[i], bottom_vecs_[i]);</span><br><span class="line">      <span class="keyword">if</span> (debug_info_) &#123; <span class="built_in">BackwardDebugInfo</span>(i); &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##caffe中的Solver
前面讲到Net通过调用Forward和Backward可以得到每个参数的梯度，而Solver的主要作用就是根据这些梯度进行网络参数的更新。由于caffe将Net作为Solver的底层实现，因此Solver也就成了控制整个训练过程的中枢。Solver提供三个主要函数：Init、Solve、ApplyUpdate。</p>
<ul>
<li>Init：创建训练网络和测试网络，初始化一些参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/caffe/solver.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="type">void</span> Solver&lt;Dtype&gt;::<span class="built_in">Init</span>(<span class="type">const</span> SolverParameter&amp; param) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Scaffolding code</span></span><br><span class="line">  <span class="built_in">InitTrainNet</span>();</span><br><span class="line">  <span class="keyword">if</span> (Caffe::<span class="built_in">root_solver</span>()) &#123;</span><br><span class="line">    <span class="built_in">InitTestNets</span>();</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Solver scaffolding done.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iter_ = <span class="number">0</span>;</span><br><span class="line">  current_step_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Solve：调用Step进行迭代训练，每次迭代后都会调用ApplyUpdate进行参数的更新</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/caffe/solver.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line">Dtype Solver&lt;Dtype&gt;::<span class="built_in">ForwardBackward</span>() &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// accumulate the loss and gradient</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; param_.<span class="built_in">iter_size</span>(); ++i) &#123;</span><br><span class="line">    loss += net_-&gt;<span class="built_in">ForwardBackward</span>();\</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> loss / param_.<span class="built_in">iter_size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="type">void</span> Solver&lt;Dtype&gt;::<span class="built_in">Step</span>(<span class="type">int</span> iters) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span> (iter_ &lt; stop_iter) &#123;</span><br><span class="line">    <span class="keyword">if</span> (param_.<span class="built_in">test_interval</span>() &amp;&amp; iter_ % param_.<span class="built_in">test_interval</span>() == <span class="number">0</span></span><br><span class="line">        &amp;&amp; (iter_ &gt; <span class="number">0</span> || param_.<span class="built_in">test_initialization</span>())</span><br><span class="line">        &amp;&amp; Caffe::<span class="built_in">root_solver</span>()) &#123;</span><br><span class="line">      <span class="built_in">TestAll</span>(); <span class="comment">// 进行测试</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; callbacks_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      callbacks_[i]-&gt;<span class="built_in">on_start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    Dtype loss = <span class="built_in">ForwardBackward</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">UpdateSmoothedLoss</span>(loss, start_iter, average_loss);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; callbacks_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      callbacks_[i]-&gt;<span class="built_in">on_gradients_ready</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">param</span>().<span class="built_in">disabled_update</span>()) &#123;</span><br><span class="line">      <span class="built_in">ApplyUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ++iter_;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="type">void</span> Solver&lt;Dtype&gt;::<span class="built_in">Solve</span>(<span class="type">const</span> <span class="type">char</span>* resume_file) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">Step</span>(param_.<span class="built_in">max_iter</span>() - iter_);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ApplyUpdate：调用对应的solver进行参数更新，下面是sgd
solver的ApplyUpdate函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/caffe/solvers/sgd_solver.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="type">void</span> SGDSolver&lt;Dtype&gt;::<span class="built_in">ApplyUpdate</span>() &#123;</span><br><span class="line">  ...</span><br><span class="line">  Dtype rate = <span class="built_in">GetLearningRate</span>(); <span class="comment">//获取当前迭代的学习率</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">ClipGradients</span>(); <span class="comment">// 进行梯度规整</span></span><br><span class="line">  <span class="comment">// learnable_params存放的是网络中所有需要学习的参数blobs</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> param_id = <span class="number">0</span>; param_id &lt; <span class="keyword">this</span>-&gt;net_-&gt;<span class="built_in">learnable_params</span>().<span class="built_in">size</span>();</span><br><span class="line">       ++param_id) &#123;</span><br><span class="line">    <span class="built_in">ApplyUpdate</span>(param_id); <span class="comment">// 逐个更新参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于梯度下降算法发展出了非常多的优化算法，目前caffe提供了六种优化算法来求解最优参数，在solver配置文件中，通过设置type类型来选择。</p>
<ul>
<li>Stochastic Gradient Descent (type: "SGD"),</li>
<li>AdaDelta (type: "AdaDelta"),</li>
<li>Adaptive Gradient (type: "AdaGrad"),</li>
<li>Adam (type: "Adam"),</li>
<li>Nesterov’s Accelerated Gradient (type: "Nesterov")</li>
<li>RMSprop (type: "RMSProp")</li>
</ul>
<p>##caffe断点保存和恢复
由于训练过程往往非常耗时，为了能够在突发情况后快速恢复训练，caffe提供了断点保存和恢复的功能，在solver的配置文件中可以配置保存的频率及保存时文件名的前缀，一个比较完整的solver配置文件如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// solver.prototxt</span></span><br><span class="line">net: <span class="string">&quot;./train_val.prototxt&quot;</span>  <span class="comment">// 定义net的protobuf文件</span></span><br><span class="line">test_iter: <span class="number">100</span>   <span class="comment">// 测试的迭代次数，这个需要根据测试数据的大小和测试时的batch size计算得到，test_iter = test_dataset_size / test_batch_size</span></span><br><span class="line">test_interval: <span class="number">1000</span>  <span class="comment">// 设置test的频率，每训练1000次迭代就测试一次</span></span><br><span class="line">base_lr: <span class="number">0.01</span>  <span class="comment">// 设置学习率</span></span><br><span class="line">lr_policy: <span class="string">&quot;step&quot;</span>  <span class="comment">// 设置学习率衰减策略</span></span><br><span class="line">gamma: <span class="number">0.1</span>  <span class="comment">// step衰减因子，</span></span><br><span class="line">stepsize: <span class="number">10000</span> <span class="comment">// 衰减的频率，每训练10000次迭代衰减一次，衰减后的学习率=当前学习率*gamma</span></span><br><span class="line">display: <span class="number">500</span>  <span class="comment">// 训练log打印频率</span></span><br><span class="line">max_iter: <span class="number">45000</span>  <span class="comment">// 设置最大训练多少次迭代</span></span><br><span class="line">type: <span class="string">&quot;SGD&quot;</span>  <span class="comment">// 设置solver类型 </span></span><br><span class="line">momentum: <span class="number">0.9</span>  <span class="comment">// 设置SGD中的动量项</span></span><br><span class="line">weight_decay: <span class="number">0.0005</span>  <span class="comment">// 设置正则系数</span></span><br><span class="line">snapshot: <span class="number">1000</span>  <span class="comment">// 设置模型保存频率</span></span><br><span class="line">snapshot_prefix: <span class="string">&quot;../output/caffe_alexnet_train&quot;</span>  <span class="comment">// 设置模型保存时文件名前缀</span></span><br><span class="line">solver_mode: CPU  <span class="comment">// 设置训练模式，CPU还是GPU</span></span><br></pre></td></tr></table></figure>
<p>当然还有一些其他的参数，比如正则化类型和模型保存文件格式等，都会使用在proto文件中定义的默认值，具体查看src/caffe/proto/caffe.proto文件中的SolverParameter。</p>
<p>为了实现断点保存和恢复，caffe在Solver中加入了Snapshot和Restore，分别进行模型保存和模型恢复，相应地，在Net中也加入了ToProto/ToHDF5和CopyTrainedLayersFromBinaryProto/CopyTrainedLayersFromHDF5。Solver调用Step进行训练的时候，每次参数更新结束都会判断是否需要保存模型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/caffe/solver.cpp:Step</span></span><br><span class="line"><span class="keyword">if</span> ((param_.<span class="built_in">snapshot</span>()</span><br><span class="line">     &amp;&amp; iter_ % param_.<span class="built_in">snapshot</span>() == <span class="number">0</span></span><br><span class="line">     &amp;&amp; Caffe::<span class="built_in">root_solver</span>()) ||</span><br><span class="line">     (request == SolverAction::SNAPSHOT)) &#123;</span><br><span class="line">  <span class="built_in">Snapshot</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Solver中Snapshot对模型参数和训练状态进行保存，模型参数提供两种保存格式——binary
protobuf和hdf5。如果是protobuf格式，则会调用Net的ToProto，否则调用ToHDF5。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/caffe/net.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="type">void</span> Net&lt;Dtype&gt;::<span class="built_in">ToProto</span>(NetParameter* param, <span class="type">bool</span> write_diff) <span class="type">const</span> &#123;</span><br><span class="line">  param-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">  param-&gt;<span class="built_in">set_name</span>(name_);</span><br><span class="line">  <span class="comment">// Add bottom and top</span></span><br><span class="line">  <span class="built_in">DLOG</span>(INFO) &lt;&lt; <span class="string">&quot;Serializing &quot;</span> &lt;&lt; layers_.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; layers&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; layers_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    LayerParameter* layer_param = param-&gt;<span class="built_in">add_layer</span>();</span><br><span class="line">    layers_[i]-&gt;<span class="built_in">ToProto</span>(layer_param, write_diff);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Solver在开始训练时会尝试调用Restore进行断点恢复，根据文件名后缀判断文件格式，并选择RestoreSolverStateFromHDF5还是RestoreSolverStateFromBinaryProto。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/caffe/solver.cpp:Solve</span></span><br><span class="line"><span class="keyword">if</span> (resume_file) &#123;</span><br><span class="line">  <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Restoring previous solver status from &quot;</span> &lt;&lt; resume_file;</span><br><span class="line">  <span class="built_in">Restore</span>(resume_file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##in-place计算
为了节约显存，caffe支持原址计算，就是输入与输出都是同一个blob。如果前一层的输出和本层的输入都与后向计算时无关，而且本层的输入和输出blob大小相同，就可以使用in-place计算，比如卷积层后面的Sigmoid、Relu等都可以用同址计算，而BatchNorm层也支持in-place计算，是因为BatchNorm在实现时会将输入数据进行备份。使用同址计算只要在protobuf文件中指定该层的top和bottom是同名的就可以了，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">layer &#123;</span><br><span class="line">        bottom: <span class="string">&quot;conv1&quot;</span></span><br><span class="line">        top: <span class="string">&quot;conv1&quot;</span></span><br><span class="line">        name: <span class="string">&quot;conv1_relu&quot;</span></span><br><span class="line">        type: <span class="string">&quot;ReLU&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##参数初始化方法
由于神经网络的目标函数往往是非凸的，参数初始化会对最终的收敛结果造成非常大的影响。为了满足不同的参数初始化需求，caffe提供了多种初始化方法，并且在net的配置文件中可以为每个参数选择一个初始化方法。比如下面的weight_filler和bias_filler：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">layer &#123;</span><br><span class="line">        bottom: <span class="string">&quot;data&quot;</span></span><br><span class="line">        top: <span class="string">&quot;conv1&quot;</span></span><br><span class="line">        name: <span class="string">&quot;conv1&quot;</span></span><br><span class="line">        type: <span class="string">&quot;Convolution&quot;</span></span><br><span class="line">        convolution_param &#123;</span><br><span class="line">                num_output: <span class="number">64</span></span><br><span class="line">                kernel_size: <span class="number">7</span></span><br><span class="line">                pad: <span class="number">3</span></span><br><span class="line">                stride: <span class="number">2</span></span><br><span class="line">                weight_filler &#123;</span><br><span class="line">                  type: <span class="string">&quot;xavier&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                bias_filler &#123;</span><br><span class="line">                  type: <span class="string">&quot;constant&quot;</span></span><br><span class="line">                  value: <span class="number">0.2</span></span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在include/caffe/filler.hpp中caffe提供如下的初始化方法：</p>
<ul>
<li>constant：常量初始化，参数所有的值都被初始化为相同的值</li>
<li>uniform：均匀初始化，参数的值按照指定区间均匀分布随机初始化</li>
<li>gaussian：高斯初始化，参数的值按照指定均值和方差的正态分布随机初始化</li>
<li>positive unitball</li>
<li>xavier：本质上也是一种指定区间均匀分布的随机初始化方式，只是区间是通过参数大小计算得到</li>
<li>msra：与xavier类似，不过使用的是指定均值和方差的正态分布随机初始化方式</li>
<li>bilinear</li>
</ul>
<p>##多卡并行策略
为了提高效率，caffe支持单机多GPU并行训练，目前采用的是数据并行方式，暂不支持模型并行，为此caffe增加了一个P2PSync类，下面主要介绍一下P2PSync如何实现多卡并行的。</p>
<p>P2PSync封装了一个Solver负责训练，每张GPU都会对应一个P2PSync，并且P2PSync之间具有主从关系，它们之间构成一个二叉树的结构。在前向计算时，主P2PSync需要将模型分发给从P2PSync，而在后向传导时，从P2PSync就需要把梯度传给主P2PSync，主P2PSync会在聚合从P2PSync的梯度后传给更上一层的主P2PSync。在二叉树结构中，根节点P2PSync的Solver被叫做root
solver，其他solver叫做worker solver，只有root
solver才能进行参数更新，worker solver只是将梯度聚合并传递给root
solver。</p>
<div data-align="center">
<img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-005.jpg?raw=true width=720>
</div>
<p>在P2PSync中主要的函数就InternalThreadEntry、on_start和on_gradients_ready。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/caffe/parallel.cpp</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="type">void</span> P2PSync&lt;Dtype&gt;::<span class="built_in">InternalThreadEntry</span>() &#123;</span><br><span class="line">...</span><br><span class="line"> solver_-&gt;<span class="built_in">Step</span>(solver_-&gt;<span class="built_in">param</span>().<span class="built_in">max_iter</span>() - initial_iter_);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>InternalThreadEntry是一个线程函数，Solver调用Step进行训练，在Step中每次前向计算前都会回调on_start获取最新模型，而在后向计算结束后又会回调on_gradients_ready传递梯度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/caffe/solver.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="type">void</span> Solver&lt;Dtype&gt;::<span class="built_in">Step</span>(<span class="type">int</span> iters) &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">while</span> (iter_ &lt; stop_iter) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; callbacks_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"> callbacks_[i]-&gt;<span class="built_in">on_start</span>(); <span class="comment">// 回调P2PSync中的on_start，从主P2PSync获取新模型</span></span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> Dtype loss = <span class="built_in">Forward_backward</span>();</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; callbacks_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"> callbacks_[i]-&gt;<span class="built_in">on_gradients_ready</span>(); <span class="comment">// 回调P2PSync中的on_gradients_ready，依次聚合从P2PSync和自身的梯度，并将梯度发送给主P2PSync</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">param</span>().<span class="built_in">disabled_update</span>()) &#123;</span><br><span class="line"> <span class="built_in">ApplyUpdate</span>(); <span class="comment">// 这里只有root solver才会进行参数更新</span></span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="type">void</span> P2PSync&lt;Dtype&gt;::<span class="built_in">on_start</span>() &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CPU_ONLY</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// Wait for update from parent</span></span><br><span class="line"> <span class="keyword">if</span> (parent_) &#123;</span><br><span class="line">   <span class="comment">/* 除了root solver，其他worker solver都有对应的parent</span></span><br><span class="line"><span class="comment">      程序执行到这里时会阻塞，当主P2PSync将自身入队后就会通知从P2PSync，pop就能返回</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   P2PSync&lt;Dtype&gt; *parent = queue_.<span class="built_in">pop</span>(); <span class="comment">// 等待主P2PSync入队</span></span><br><span class="line">   <span class="built_in">CHECK</span>(parent == parent_);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// Update children</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = children_.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">   Dtype* src = data_;</span><br><span class="line">   Dtype* dst = children_[i]-&gt;data_;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 主P2PSync将模型直接拷贝给从P2PSync</span></span><br><span class="line">   <span class="built_in">CUDA_CHECK</span>(<span class="built_in">cudaMemcpyAsync</span>(dst, src, size_ * <span class="built_in">sizeof</span>(Dtype),</span><br><span class="line">   cudaMemcpyDeviceToDevice, cudaStreamDefault));</span><br><span class="line">   <span class="built_in">CUDA_CHECK</span>(<span class="built_in">cudaStreamSynchronize</span>(cudaStreamDefault));</span><br><span class="line">   <span class="comment">// 主P2PSync将自身入队，并通知从P2PSync</span></span><br><span class="line">   children_[i]-&gt;queue_.<span class="built_in">push</span>(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="type">void</span> P2PSync&lt;Dtype&gt;::<span class="built_in">on_gradients_ready</span>() &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CPU_ONLY</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Sum children gradients as they appear in the queue</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; children_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    P2PSync&lt;Dtype&gt; *child = queue_.<span class="built_in">pop</span>(); <span class="comment">// 等待从P2PSync入队</span></span><br><span class="line">    <span class="comment">// 由于parent_grads_是在主P2PSync设备上开辟的一块缓冲区，因此child-&gt;parent_grads_其实就是当前设备上的缓冲区</span></span><br><span class="line">    Dtype* src = child-&gt;parent_grads_; <span class="comment">// 获取从P2PSync的梯度</span></span><br><span class="line">    Dtype* dst = diff_;</span><br><span class="line">    <span class="comment">// 合并从P2PSync的梯度</span></span><br><span class="line">    <span class="built_in">caffe_gpu_add</span>(size_, src, dst, dst);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Send gradients to parent</span></span><br><span class="line">  <span class="keyword">if</span> (parent_) &#123;</span><br><span class="line">    Dtype* src = diff_;</span><br><span class="line">    Dtype* dst = parent_grads_; </span><br><span class="line">    <span class="comment">// 从P2PSync将梯度复制到主P2PSync的缓冲区</span></span><br><span class="line">    <span class="built_in">CUDA_CHECK</span>(<span class="built_in">cudaMemcpyAsync</span>(dst, src, size_ * <span class="built_in">sizeof</span>(Dtype),  <span class="comment">//</span></span><br><span class="line">        cudaMemcpyDeviceToDevice, cudaStreamDefault));</span><br><span class="line">    <span class="built_in">CUDA_CHECK</span>(<span class="built_in">cudaStreamSynchronize</span>(cudaStreamDefault));</span><br><span class="line">    <span class="comment">// 自身入队，通知主P2PSync</span></span><br><span class="line">    parent_-&gt;queue_.<span class="built_in">push</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Loss functions divide gradients by the batch size, so to compensate</span></span><br><span class="line">    <span class="comment">// for split batch, the root solver divides by number of solvers.</span></span><br><span class="line">    <span class="built_in">caffe_gpu_scal</span>(size_, <span class="built_in">Dtype</span>(<span class="number">1.0</span> / Caffe::<span class="built_in">solver_count</span>()), diff_);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>##intel caffe多机并行策略
单机多卡的训练方式已经足够解决目前大部分模型训练的需求了，但随着数据量越来越大、模型越来越复杂，分布式异构计算成为行业通行的解决方案。BVLC
caffe是不支持分布式训练的，intel有两个部门将caffe进行了再次开发以支持分布式和最新的Intel
MKL-DNN，分别为intel caffe和caffe multinode。目前BML API已经支持intel
caffe的模型训练、评估和预测了。</p>
<p>intel caffe采用的是数据并行的方式，但不同于目前主流的centralized
parameter server通信模型，intel
caffe借鉴了单机多卡的策略，采用的是一种all-reduce的binary
tree模型，也就是将节点按照二叉树组织起来，每个父节点负责1-2个子节点和自己父节点的通信，相比一个中心的PS需要同时与其他多个节点通信的方式，这种binary
tree方式将一部分PS的计算平均到了每个节点上，而且相同level的父节点之间可以并行，增加了梯度合并的并行度。</p>
<p>[待图]</p>
<p>为了更好地掩盖通信开销，子节点不需要等到整个模型的梯度都计算完才发送，而是每个layer计算完梯度后就会立即发送给父节点，父节点收到所有子节点的梯度后将本层的梯度合并后也可以立即发送给上一层的父节点。每个layer的参数会按照buffer的大小分成多个part，每个part都会异步地进行发送，当进行下一次迭代时，除了根节点的所有节点都会被阻塞，等待根节点将最终的梯度进行合并，并更新模型后发送给子节点。</p>
<p>除了分层通信外，intel
caffe也支持梯度量化压缩，可以将全精浮点数编码成指定字节数的数值，减少节点间通信量。</p>
<p>intel
caffe为了支持多种协议的通信，使用了boost的asio::io_service接口，底层实现支持MPI、TCP和UDP，不过目前只实现了MPI接口。</p>
<p>训练时交叉验证是在单节点(准确来说是根节点)上进行的，但每个节点上都需要存在验证集文件，这是因为即使不进行test，其他节点也会初始化test网络。</p>
<p>##实战</p>
<p>##参考 贾扬清自述http://www.yangfenzi.com/keji/59535.html<br />
caffe官网http://caffe.berkeleyvision.org<br />
http://ucb-icsi-vision-group.github.io/caffe-paper/caffe.pdf<br />
https://www.zhihu.com/question/27982282<br />
http://blog.csdn.net/myarrow/article/details/52064608</p>

      
    </div>
      
      <footer>
        
  
  <div class="categories">
    <a href="/categories/ML-framework/">ML framework</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/caffe/">caffe</a>, <a href="/tags/deep-learning/">deep learning</a>, <a href="/tags/framework/">framework</a>
  </div>

        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>


<section id="comment">
  
</section>




  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:hjchen2.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2023/02/24/IREE编译流程6/">IREE编译流程解析(六)</a>
      </li>
    
      <li>
        <a href="/2023/02/13/IREE编译流程5/">IREE编译流程解析(五)</a>
      </li>
    
      <li>
        <a href="/2023/01/04/IREE编译流程4/">IREE编译流程解析(四)</a>
      </li>
    
      <li>
        <a href="/2023/01/04/IREE编译流程3/">IREE编译流程解析(三)</a>
      </li>
    
      <li>
        <a href="/2023/01/04/IREE编译流程2/">IREE编译流程解析(二)</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/DL-Compiler/">DL Compiler</a><small>8</small></li>
  
    <li><a href="/categories/Daily/">Daily</a><small>1</small></li>
  
    <li><a href="/categories/ML-framework/">ML framework</a><small>2</small></li>
  
    <li><a href="/categories/XRT/">XRT</a><small>1</small></li>
  
    <li><a href="/categories/code/">code</a><small>1</small></li>
  
    <li><a href="/categories/deep-learning/">deep learning</a><small>1</small></li>
  
    <li><a href="/categories/graph-optimization-图优化/">graph optimization, 图优化</a><small>1</small></li>
  
    <li><a href="/categories/kaldi-decision-tree-决策树/">kaldi, decision tree, 决策树</a><small>1</small></li>
  
    <li><a href="/categories/low-bitwidth/">low bitwidth</a><small>1</small></li>
  
    <li><a href="/categories/model-compression/">model compression</a><small>1</small></li>
  
    <li><a href="/categories/neural-machine-translation/">neural machine translation</a><small>1</small></li>
  
    <li><a href="/categories/reinforcement-learning/">reinforcement learning</a><small>3</small></li>
  
    <li><a href="/categories/tvm-knowledge/">tvm knowledge</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2023 Dou Jiang
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>



</body>
</html>

